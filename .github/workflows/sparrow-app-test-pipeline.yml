# File: .github/workflows/sparrow-app-test-pipeline.yml
# This file is used to test the Sparrow App build and release process. Change this file to trigger the test pipeline for Sparrow App.
# It is triggered on push to the <branch_name> branch. Change the branch name to trigger the test pipeline.

name: Test release

on:
  push:
    # Trigger on push to the <branch_name> branch. Make sure to remove the branch name from the branches list below, once you are done testing.
    branches:
      - fix/msix-build
  workflow_dispatch:

env:
  VITE_API_URL: ${{ vars.VITE_API_URL_DEV }}
  VITE_MIX_PANEL_TOKEN: ${{ vars.VITE_MIX_PANEL_TOKEN }}
  VITE_ENABLE_MIX_PANEL: ${{ vars.VITE_ENABLE_MIX_PANEL_DEV }}
  VITE_API_TIMEOUT: ${{ vars.VITE_API_TIMEOUT }}
  VITE_SPARROW_SUPPORT_EMAIL: ${{ vars.VITE_SPARROW_SUPPORT_EMAIL }}
  VITE_AUTH_URL: ${{ vars.VITE_AUTH_URL_DEV }}
  VITE_SPARROW_GITHUB: ${{ vars.VITE_SPARROW_GITHUB }}
  VITE_SPARROW_DOWNLOAD_LINK: ${{ vars.VITE_SPARROW_DOWNLOAD_LINK }}
  VITE_RELEASE_NOTES_PAT_TOKEN: ${{ secrets.VITE_RELEASE_NOTES_PAT_TOKEN }}
  VITE_RELEASE_NOTES_API: ${{ vars.VITE_RELEASE_NOTES_API }}
  VITE_AZURE_CDN_URL: ${{ vars.VITE_AZURE_CDN_URL }}
  VITE_AZURE_INSIGHTS_CONNECTION_STRING: ${{ vars.VITE_AZURE_INSIGHTS_CONNECTION_STRING }}
  VITE_CANNY_API: ${{ vars.VITE_CANNY_API }}
  VITE_CANNY_URL: ${{ vars.VITE_CANNY_URL }}
  VITE_BASE_URL: ${{ vars.VITE_BASE_URL }}
  VITE_SPARROW_LINKEDIN: ${{ vars.VITE_SPARROW_LINKEDIN }}
  VITE_WEB_SOCKET_IO_API_URL: ${{ vars.VITE_WEB_SOCKET_IO_API_URL }}
  VITE_SPARROW_DOCS: ${{ vars.VITE_SPARROW_DOCS }}
  VITE_SPARROW_AI_WEBSOCKET: ${{ vars.VITE_SPARROW_AI_WEBSOCKET }}
  VITE_APP_ENVIRONMENT_PATH: ${{ vars.VITE_APP_ENVIRONMENT_PATH }}
  VITE_CANNY_FEEDBACK_URL: ${{ vars.VITE_CANNY_FEEDBACK_URL }}
  VITE_SPARROW_WEB_APP_URL: ${{ vars.VITE_SPARROW_WEB_APP_URL }}
  VITE_MARKETING_URL: ${{ vars.VITE_MARKETING_URL }}
  VITE_SENTRY_DSN: ${{ vars.VITE_SENTRY_DSN }}
  VITE_APP_ENVIRONMENT: ${{ vars.VITE_APP_ENVIRONMENT }}
  VITE_POSTHOG_CONNECTION_API_KEY: ${{ vars.VITE_POSTHOG_CONNECTION_API_KEY }}
  VITE_POSTHOG_API_URL: ${{ vars.VITE_POSTHOG_API_URL }}
  VITE_SPARROW_ADMIN_URL: ${{ vars.VITE_SPARROW_ADMIN_URL }}
  ACTIONS_ALLOW_UNSECURE_COMMANDS: true
  CI: false

jobs:
  build_and_sign_msix:
    runs-on: windows-2025
    environment: production

    steps:
      # --- STAGE 1: BUILD TAURI APP (MSI ONLY) ---
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Windows 10 SDK
        run: choco install windows-sdk-10-version-2004-all -y
        shell: powershell

      # - name: Setup Node.js
      #   uses: actions/setup-node@v2
      #   with:
      #     node-version: "20.8"

      # - name: Install Rust 1.82.0
      #   run: |
      #     Invoke-WebRequest -Uri https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe -OutFile rustup-init.exe
      #     .\rustup-init.exe -y
      #     rustup install 1.82.0
      #     rustup default 1.82.0

      # - name: Update updater endpoint in tauri.conf.json file
      #   run: |
      #     $content = Get-Content apps/@sparrow-desktop/src-tauri/tauri.conf.json -Raw
      #     $newContent = $content -replace '"https://{{UPDATER_URL}}/updater/{{target}}/{{arch}}/{{current_version}}"', '"https://${{ secrets.UPDATER_ENDPOINT_PROD }}/updater/{{target}}/{{arch}}/{{current_version}}"'
      #     Set-Content -Path apps/@sparrow-desktop/src-tauri/tauri.conf.json -Value $newContent
      #   shell: pwsh

      # - name: Increase Yarn network timeout
      #   run: yarn config set network-timeout 600000

      # - name: Sync version across all files
      #   run: yarn sync-version

      # - name: Build Tauri App
      #   run: |
      #     yarn cache clean
      #     npm install -g pnpm
      #     yarn install
      #     yarn desktop-build
      #   env:
      #     TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      #     TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
      #     GITHUB_TOKEN: ${{ secrets.PR_GITHUB_TOKEN }}

      # - name: Upload MSI and EXE as Artifacts
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: tauri-build-artifacts
      #     path: |
      #       apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/*.msi
      #       apps/@sparrow-desktop/src-tauri/target/debug/Sparrow.exe

      - name: Copy unsigned MSI and EXE from prebuilt
        run: |
          # Create target directory structure
          New-Item -ItemType Directory -Force -Path "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi"
          
          # Copy MSI to where the pipeline expects it
          $msi = Get-ChildItem -Path "prebuilt/Sparrow_*_x64_en-US.msi" | Select-Object -First 1
          if (-not $msi) {
            Write-Host "::error::No MSI found in prebuilt folder"
            exit 1
          }

          # Copy EXE to where the pipeline expects it
          $exe = Get-ChildItem -Path "prebuilt/Sparrow.exe" | Select-Object -First 1
          if (-not $exe) {
            Write-Host "::error::No EXE found in prebuilt folder"
            exit 1
          } 
          
          Copy-Item $msi.FullName -Destination "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/Sparrow.msi"
          Write-Host "Copied $($msi.Name) to standard location"

          Copy-Item $exe.FullName -Destination "apps/@sparrow-desktop/src-tauri/target/debug/Sparrow.exe"
          Write-Host "Copied $($exe.Name) to standard location"
        shell: powershell

      # --- STAGE 2: SIGN MSI WITH DIGICERT ---
      - name: Setup and Verify DigiCert Certificate & Environment
        shell: pwsh
        run: |
          # Enable strict error handling
          $ErrorActionPreference = "Stop"
          
          Write-Host "=== Setting up DigiCert Certificate and Environment Variables ==="
          
          # 1. Environment Variables Setup
          Write-Host "`n[1/3] Configuring Environment Variables..."
          $requiredSecrets = @{
            "SM_HOST" = "${{ secrets.SM_HOST }}"
            "SM_API_KEY" = "${{ secrets.SM_API_KEY }}"
            "SM_CLIENT_CERT_PASSWORD" = "${{ secrets.SM_CLIENT_CERT_PASSWORD }}"
          }

          # Verify secrets exist before proceeding
          foreach ($key in $requiredSecrets.Keys) {
            if ([string]::IsNullOrEmpty($requiredSecrets[$key])) {
              Write-Host "::error::Missing required secret: $key"
              exit 1
            }
          }

          # Set environment variables using multiple methods for reliability
          try {
            # Method 1: GitHub Environment File
            "SM_HOST=$($requiredSecrets.SM_HOST)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "SM_API_KEY=$($requiredSecrets.SM_API_KEY)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "SM_CLIENT_CERT_PASSWORD=$($requiredSecrets.SM_CLIENT_CERT_PASSWORD)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            
            # Method 2: Immediate session variables
            $env:SM_HOST = $requiredSecrets.SM_HOST
            $env:SM_API_KEY = $requiredSecrets.SM_API_KEY
            $env:SM_CLIENT_CERT_PASSWORD = $requiredSecrets.SM_CLIENT_CERT_PASSWORD
            
            Write-Host "✓ Environment variables set successfully"
          }
          catch {
            Write-Host "::warning::Partial environment setup: $($_.Exception.Message)"
          }

          # 2. Certificate Decoding
          Write-Host "`n[2/3] Processing Certificate..."
          $certPath = "${{ github.workspace }}\Certificate_pkcs12.p12"
          $certBase64 = "${{ secrets.SM_CLIENT_CERT_FILE_B64 }}".Trim()

          # Validate certificate secret
          if ([string]::IsNullOrWhiteSpace($certBase64)) {
            Write-Host "::error::SM_CLIENT_CERT_FILE_B64 secret is empty or not set"
            exit 1
          }

          # Clean and validate Base64
          $cleanBase64 = $certBase64 -replace '\s',''
          if ($cleanBase64.Length % 4 -ne 0) {
            Write-Host "::warning::Base64 length not multiple of 4 (may need padding)"
            $cleanBase64 = $cleanBase64.PadRight($cleanBase64.Length + (4 - $cleanBase64.Length % 4) % 4, '=')
          }

          try {
            # Decode and save certificate
            $certBytes = [Convert]::FromBase64String($cleanBase64)
            [IO.File]::WriteAllBytes($certPath, $certBytes)
            
            # Set certificate path
            "SM_CLIENT_CERT_FILE=$certPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            $env:SM_CLIENT_CERT_FILE = $certPath
            
            Write-Host "✓ Certificate saved to $certPath ($($certBytes.Length) bytes)"
          }
          catch {
            Write-Host "::error::Certificate processing failed: $($_.Exception.Message)"
            Write-Host "Debug info: Base64 length=$($certBase64.Length), Clean length=$($cleanBase64.Length)"
            exit 1
          }

          # 3. Validation Phase
          Write-Host "`n[3/3] Running Validations..."
          
          # Certificate Validation
          try {
            $cert = New-Object Security.Cryptography.X509Certificates.X509Certificate2(
              $certPath,
              $requiredSecrets.SM_CLIENT_CERT_PASSWORD,
              [Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
            )
            
            Write-Host "✓ Certificate Validated:"
            Write-Host "   Subject: $($cert.Subject)"
            Write-Host "   Thumbprint: $($cert.Thumbprint)"
            Write-Host "   Expires: $($cert.NotAfter.ToString('yyyy-MM-dd'))"
            $cert.Dispose()
          }
          catch {
            Write-Host "::error::Certificate validation failed: $($_.Exception.Message)"
            exit 1
          }

          # Environment Verification
          $missingVars = @()
          foreach ($var in @("SM_HOST", "SM_API_KEY", "SM_CLIENT_CERT_PASSWORD", "SM_CLIENT_CERT_FILE")) {
            if (-not (Test-Path "env:$var")) {
              $missingVars += $var
            }
          }

          if ($missingVars.Count -gt 0) {
            Write-Host "::warning::These variables didn't persist: $($missingVars -join ', ')"
            Write-Host "Current environment:"
            Get-ChildItem env: | Where-Object Name -like "SM_*" | Format-Table Name, @{
              Label="Value";
              Expression={ if ($_.Name -like "*KEY*" -or $_.Name -like "*PASSWORD*") { "*****" } else { $_.Value } }
            }
          }
          else {
            Write-Host "✓ All environment variables confirmed"
          }

          Write-Host "`n✅ Setup and Verification Completed Successfully"

      # Setup Android SDK (required by DigiCert action for compatibility)
      - name: Setup Android SDK (for DigiCert action compatibility)
        run: |
          # Create minimal Android SDK structure to satisfy DigiCert action requirements
          $androidSdkPath = "C:\Android\android-sdk"
          $buildToolsPath = "$androidSdkPath\build-tools\30.0.2"
          
          Write-Host "Creating Android SDK directory structure..." -ForegroundColor Yellow
          New-Item -ItemType Directory -Path $buildToolsPath -Force
          
          # Create dummy files that the DigiCert action expects to find
          Write-Host "Creating required Android build tool files..." -ForegroundColor Yellow
          New-Item -ItemType File -Path "$buildToolsPath\apksigner.bat" -Force
          New-Item -ItemType File -Path "$buildToolsPath\zipalign.exe" -Force
          New-Item -ItemType File -Path "$buildToolsPath\aapt.exe" -Force
          New-Item -ItemType File -Path "$buildToolsPath\aapt2.exe" -Force
          
          # Set Android environment variables
          echo "ANDROID_HOME=$androidSdkPath" >> $env:GITHUB_ENV
          echo "ANDROID_SDK_ROOT=$androidSdkPath" >> $env:GITHUB_ENV
          
          Write-Host "Android SDK structure created successfully" -ForegroundColor Green
        shell: powershell

      # Install DigiCert Signing Manager Tools
      - name: Install DigiCert Signing Manager Tools
        uses: digicert/ssm-code-signing@v1.0.0

      - name: Extract first KeyPair alias
        id: extract_alias
        shell: pwsh
        run: |
          Write-Host "=== Getting keypair information ==="
          
          # Get keypair list and capture output
          $keypairOutput = smctl keypair ls 2>&1
          Write-Host "Keypair command output:"
          Write-Host $keypairOutput
          
          # Parse the output more carefully
          $lines = $keypairOutput -split "`n"
          Write-Host "Total lines: $($lines.Count)"
          
          # Find the first data line (skip header lines)
          $dataLine = $null
          for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i].Trim()
              Write-Host "Line $i`: $line"
              
              # Skip empty lines and header lines
              if ($line -and $line -notmatch "^-+$" -and $line -notmatch "^ID\s+") {
                  $dataLine = $line
                  Write-Host "Found data line: $dataLine"
                  break
              }
          }
          
          if (-not $dataLine) {
              Write-Host "::error::No keypair data found"
              exit 1
          }
          
          # Extract alias (typically the third column)
          $parts = $dataLine -split '\s{2,}'
          Write-Host "Split parts: $($parts -join ' | ')"
          
          if ($parts.Count -lt 3) {
              Write-Host "::error::Could not parse keypair line: $dataLine"
              exit 1
          }
          
          $alias = $parts[2].Trim()
          Write-Host "✅ Extracted alias: '$alias'"
          
          if (-not $alias) {
              Write-Host "::error::Alias is empty"
              exit 1
          }
          
          # Set environment variable for subsequent steps
          Add-Content -Path $env:GITHUB_ENV -Value "KEYPAIR_ALIAS=$alias"
          Write-Host "✅ Set KEYPAIR_ALIAS environment variable"
      
      - name: Sync Certificate into Windows Store
        shell: pwsh
        run: |
          # Sync to both stores to be sure
          smctl windows certsync --keypair-alias="$env:KEYPAIR_ALIAS"
          smctl windows certsync --keypair-alias="$env:KEYPAIR_ALIAS" --store=system
          
          # Give it a moment to sync
          Start-Sleep -Seconds 5
          
          # Verify the certificate is available
          $certThumb = "${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }}"
          $cert = Get-ChildItem -Path "Cert:\CurrentUser\My" | Where-Object { $_.Thumbprint -eq $certThumb }
          if (-not $cert) {
            $cert = Get-ChildItem -Path "Cert:\LocalMachine\My" | Where-Object { $_.Thumbprint -eq $certThumb }
          }
          
          if (-not $cert) {
            Write-Host "::error::Certificate still not found after sync"
            exit 1
          }
          
          Write-Host "✅ Certificate synced successfully"


      # --- STAGE 3: CONVERT TO MSIX USING MAKEAPPX ---
      - name: Prepare App Folder for MakeAppx
        run: |
          New-Item -ItemType Directory -Force -Path "app-root/Assets"
          $msiPath = Get-ChildItem -Path "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi" -Filter "Sparrow_*_x64_en-US.msi" | Select-Object -First 1
          $extractPath = "app-root"
          Start-Process msiexec.exe -ArgumentList "/a `"$msiPath`" /qn TARGETDIR=`"$extractPath`"" -Wait -NoNewWindow

          #Copy app executable (MakeAppx requires it)
          $exeSource = Get-ChildItem -Path "apps/@sparrow-desktop/src-tauri/target/debug" -Filter "Sparrow.exe" -Recurse | Select-Object -First 1
          if ($exeSource) {
            Copy-Item $exeSource.FullName -Destination "app-root/Sparrow.exe"
          } else {
            Write-Host "::warning::Real Sparrow.exe not found. Inserting dummy executable."
            Set-Content -Path "app-root/Sparrow.exe" -Value "placeholder"
          }

           # Copy actual StoreLogo from known path
          $logo = "apps/@sparrow-desktop/src-tauri/icons/StoreLogo.png"
          Copy-Item $logo -Destination "app-root/Assets/StoreLogo.png"
          Copy-Item $logo -Destination "app-root/Assets/Square150x150Logo.png"
          Copy-Item $logo -Destination "app-root/Assets/Square44x44Logo.png"
          Copy-Item $logo -Destination "app-root/Assets/SplashScreen.png"

        shell: powershell

      - name: Generate AppxManifest.xml with version injection
        run: |
          $cargoFile = "apps/@sparrow-desktop/src-tauri/Cargo.toml"
          $versionLine = Select-String -Path $cargoFile -Pattern '^[\s]*version\s*=\s*\"(.*?)\"' | Select-Object -First 1
          $version = $versionLine.Matches.Groups[1].Value

          $manifest = @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
                  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
                  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
                  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
                  IgnorableNamespaces="uap mp rescap">
            <Identity Name="Sparrow"
                      Publisher="CN=Techdome Solutions, O=Techdome Solutions, C=IN"
                      Version="$version.0"
                      ProcessorArchitecture="x64" />
            <Properties>
              <DisplayName>Sparrow</DisplayName>
              <PublisherDisplayName>sparrowapp</PublisherDisplayName>
              <Description>Sparrow</Description>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.0.0" MaxVersionTested="10.0.19041.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-us" />
            </Resources>
            <Capabilities>
              <rescap:Capability Name="runFullTrust" />
            </Capabilities>
            <Applications>
              <Application Id="SparrowApp" Executable="Sparrow.exe" EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements DisplayName="Sparrow"
                                    Description="Sparrow App"
                                    BackgroundColor="transparent"
                                    Square150x150Logo="Assets\Square150x150Logo.png"
                                    Square44x44Logo="Assets\Square44x44Logo.png">
                </uap:VisualElements>
              </Application>
            </Applications>
          </Package>
          "@

          $manifest | Set-Content -Encoding UTF8 -Path "app-root\AppxManifest.xml"
        shell: powershell

      # - name: Create MSIX Package using MakeAppx
      #   run: |
      #     New-Item -ItemType Directory -Force -Path "msix-output"
      #     $msixPath = "msix-output/sparrow.msix"

      #     $makeAppx = Get-ChildItem -Path 'C:\Program Files (x86)\Windows Kits\10\bin' -Recurse -Filter MakeAppx.exe -ErrorAction SilentlyContinue |
      #                 Where-Object { $_.FullName -match '\\x64\\MakeAppx\.exe$' } |
      #                 Sort-Object LastWriteTime -Descending |
      #                 Select-Object -First 1

      #     if (-not $makeAppx) {
      #       Write-Host "::error::MakeAppx.exe not found. Please ensure Windows 10 SDK is available on this runner."
      #       exit 1
      #     }

      #     Write-Host "✅ Found MakeAppx.exe at: $($makeAppx.FullName)"
      #     & "$($makeAppx.FullName)" pack /d "app-root" /p $msixPath
      #   shell: powershell

      # # --- STAGE 4: SIGN MSIX WITH DIGICERT ---
      # - name: Sign MSIX Package
      #   shell: pwsh
      #   run: |
      #     # Enable strict error handling
      #     $ErrorActionPreference = "Stop"
          
      #     # 1. Configure paths and parameters
      #     $msixPath = "msix-output/sparrow.msix"
      #     $timestampServer = "http://timestamp.digicert.com"
      #     $signToolPath = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe"
          
      #     # 2. Pre-signing validation
      #     Write-Host "`n=== Pre-Signing Validation ==="
          
      #     # Verify MSIX exists
      #     if (-not (Test-Path -Path $msixPath -PathType Leaf)) {
      #       Write-Host "::error::MSIX file not found at $msixPath"
      #       Get-ChildItem -Path "msix-output" | Format-Table Name, Length | Out-String | Write-Host
      #       exit 1
      #     }
          
      #     # Verify certificate is accessible
      #     if (-not (Test-Path -Path $env:SM_CLIENT_CERT_FILE)) {
      #       Write-Host "::error::Certificate file not found at $env:SM_CLIENT_CERT_FILE"
      #       exit 1
      #     }
          
      #     # Verify signtool exists
      #     if (-not (Test-Path -Path $signToolPath)) {
      #       Write-Host "::error::SignTool not found at $signToolPath"
      #       Write-Host "Available Windows Kits versions:"
      #       Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" | Format-Table Name | Out-String | Write-Host
      #       exit 1
      #     }
          
      #     # 3. Prepare signing command
      #     $signArgs = @(
      #       "sign",
      #       "/fd", "sha256",
      #       "/f", "`"$env:SM_CLIENT_CERT_FILE`"",
      #       "/p", "`"$env:SM_CLIENT_CERT_PASSWORD`"",
      #       "/tr", $timestampServer,
      #       "/td", "sha256",
      #       "/v",
      #       "`"$msixPath`""
      #     )
          
      #     Write-Host "`n=== Signing Command ==="
      #     Write-Host "$signToolPath $($signArgs -join ' ')"
          
      #     # 4. Execute signing with retry logic
      #     $maxRetries = 3
      #     $retryCount = 0
      #     $signed = $false
          
      #     while (-not $signed -and $retryCount -lt $maxRetries) {
      #       try {
      #         $retryCount++
      #         Write-Host "`nAttempt $retryCount of $maxRetries..."
              
      #         # Clear any previous errors
      #         $LASTEXITCODE = 0
              
      #         # Execute signing
      #         & $signToolPath $signArgs
              
      #         if ($LASTEXITCODE -ne 0) {
      #           throw "SignTool failed with exit code $LASTEXITCODE"
      #         }
              
      #         $signed = $true
      #         Write-Host "✓ Successfully signed $msixPath"
      #       }
      #       catch {
      #         Write-Host "::warning::Signing attempt $retryCount failed: $($_.Exception.Message)"
              
      #         # Additional diagnostics on last attempt
      #         if ($retryCount -eq $maxRetries) {
      #           Write-Host "`n=== Final Attempt Diagnostics ==="
                
      #           # Verify certificate can be loaded
      #           try {
      #             $cert = New-Object Security.Cryptography.X509Certificates.X509Certificate2(
      #               $env:SM_CLIENT_CERT_FILE,
      #               $env:SM_CLIENT_CERT_PASSWORD,
      #               [Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
      #             )
      #             Write-Host "✓ Certificate is valid:"
      #             Write-Host "   Thumbprint: $($cert.Thumbprint)"
      #             Write-Host "   Has Private Key: $($cert.HasPrivateKey)"
      #             Write-Host "   Not After: $($cert.NotAfter)"
      #             $cert.Dispose()
      #           }
      #           catch {
      #             Write-Host "::error::Certificate validation failed: $($_.Exception.Message)"
      #           }
                
      #           # Check file signatures
      #           Write-Host "`nFile signatures:"
      #           & $signToolPath verify /pa /v "`"$msixPath`""
                
      #           exit 1
      #         }
              
      #         # Wait before retry
      #         Start-Sleep -Seconds (5 * $retryCount)
      #       }
      #     }
          
      #     # 5. Post-signing verification
      #     if ($signed) {
      #       Write-Host "`n=== Signature Verification ==="
      #       & $signToolPath verify /pa /v "`"$msixPath`""
            
      #       if ($LASTEXITCODE -ne 0) {
      #         Write-Host "::error::Signature verification failed"
      #         exit 1
      #       }
            
      #       Write-Host "`n✅ Package signed and verified successfully"
      #     }


      - name: Create and Sign MSIX Package
        shell: pwsh
        env:
          # Environment variables to prevent crypto provider caching issues
          COMPlus_EnableDiagnostics: 0
          CRYPTNET_CRL_AUTODISCOVERY_OPT_IN: 0
        run: |
          # 1. Configure paths
          $msixDir = "msix-output"
          $msixPath   = Join-Path $PWD "$msixDir\sparrow.msix"
          $appRoot = "app-root"
          $backupPath = "$msixPath.backup"

          # 2. Create output directory
          New-Item -ItemType Directory -Force -Path $msixDir | Out-Null

          # 3. Find MakeAppx tool (latest version)
          $makeAppx = Get-ChildItem -Path 'C:\Program Files (x86)\Windows Kits\10\bin' -Recurse -Filter MakeAppx.exe -ErrorAction SilentlyContinue |
                      Where-Object { $_.FullName -match '\\x64\\MakeAppx\.exe$' } |
                      Sort-Object LastWriteTime -Descending |
                      Select-Object -First 1


          if (-not $makeAppx) {
              Write-Host "::error::MakeAppx.exe not found"
              exit 1
          }
          Write-Host "✓ Using MakeAppx: $($makeAppx.FullName)"

          # 4. Create MSIX package
          try {
          
              & $makeAppx.FullName pack /d $appRoot /p $msixPath /l /o
              if ($LASTEXITCODE -ne 0) {
                  throw "MakeAppx failed with exit code $LASTEXITCODE"
              }
              Write-Host "✓ MSIX package created: $msixPath"
              Write-Host "Package size: $((Get-Item $msixPath).Length/1KB) KB"
          }
          catch {
              & "$($makeAppx.FullName)" pack /d "app-root" /p $msixPath
              Write-Host "✓ MSIX package created 1: $msixPath"
          }

          # 5. Signing preparation
          $signTool = $makeAppx.Directory.FullName + "\signtool.exe"
          
          try {
              # Verify signing tools exist
              if (-not (Test-Path $signTool)) {
                  throw "SignTool not found at $signTool"
              }

              # 6. Import certificate to Personal store
              $certPassword = ConvertTo-SecureString -String $env:SM_CLIENT_CERT_PASSWORD -AsPlainText -Force
              $cert = Import-PfxCertificate -FilePath $env:SM_CLIENT_CERT_FILE `
                                     -CertStoreLocation Cert:\CurrentUser\My `
                                     -Password $certPassword `
                                     -Exportable `
                                     -KeyStorageFlags @(
                                        'UserKeySet',
                                        'PersistKeySet',
                                        'Exportable'
                                     )
              if (-not $cert) {
                  throw "Failed to import certificate to store"
              }
              Write-Host "✓ Certificate imported (Thumbprint: $($cert.Thumbprint))"
              Write-Host "Certificate Subject: $($cert.Subject)"
              Write-Host "Has Private Key: $($cert.HasPrivateKey)"

              # 7. Execute signing with retries
              $maxRetries = 3
              $retryCount = 0
              $signed = $false

              while (-not $signed -and $retryCount -lt $maxRetries) {
                  $retryCount++
                  try {
                      Write-Host "`nSigning attempt $retryCount of $maxRetries..."

                      # Create backup of MSIX
                      Copy-Item -Path $msixPath -Destination $backupPath -Force

                      # Sign using certificate store
                      & $signTool sign `
                          /sm `
                          /s My `
                          /sha1 $cert.Thumbprint `
                          /tr http://timestamp.digicert.com `
                          /td sha256 `
                          /fd sha256 `
                          /v `
                          /debug `
                          "`"$msixPath`""

                      if ($LASTEXITCODE -ne 0) {
                          # Restore backup if signing failed
                          Copy-Item -Path $backupPath -Destination $msixPath -Force
                          throw "SignTool failed with exit code $LASTEXITCODE"
                      }

                      $signed = $true
                      Write-Host "✓ Successfully signed package"
                  }
                  catch {
                    Write-Host "::warning::Attempt $retryCount failed: $($_.Exception.Message)"
                    
                    # Additional diagnostics on last attempt
                    if ($retryCount -eq $maxRetries) {
                        Write-Host "=== Certificate Store Debug ==="
                        Get-ChildItem Cert:\CurrentUser\My | Format-List Thumbprint,Subject,NotAfter,HasPrivateKey
                        
                        Write-Host "=== Private Key Access Test ==="
                        try {
                            $rsaKey = [System.Security.Cryptography.X509Certificates.RSACertificateExtensions]::GetRSAPrivateKey($cert)
                            Write-Host "Private key accessible: $($null -ne $rsaKey)"
                        }
                        catch {
                            Write-Host "Private key access failed: $($_.Exception.Message)"
                        }
                    }
                    
                    Start-Sleep -Seconds (2 * $retryCount)
                  }
              }

              # 7. Verify signature
              & $signTool verify /pa /v "`"$msixPath`""
              if ($LASTEXITCODE -ne 0) {
                  throw "Signature verification failed"
              }

              Write-Host "✅ Package signed and verified successfully"
          }
          catch {
              Write-Host "::error::Signing failed: $($_.Exception.Message)"
              Write-Host "=== Debug Info ==="
              Write-Host "MSIX exists: $(Test-Path $msixPath)"
              Write-Host "SignTool: $signTool"
              exit 1
          }
      # - name: Sign MSIX with DigiCert SMCTLSign (using fingerprint)
      #   run: |
      #     if (-Not (Test-Path msix-output/sparrow.msix)) {
      #         Write-Host "MSIX file not found at msix-output/sparrow.msix"
      #     }

      #     Write-Host "Signing: msix-output/sparrow.msix with DigiCert SMCTLSign"
          
      #     $certFingerprint = "${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }}"
      #     Write-Host "Using certificate fingerprint: $certFingerprint"
          
      #     # Use certificate fingerprint instead of keypair alias
      #     smctl sign --certificate-fingerprint="$certFingerprint" --input="msix-output/sparrow.msix"
          
      #     if ($LASTEXITCODE -ne 0) {
      #         Write-Host "Failed to sign msix-output/sparrow.msix with SMCTLSign"
      #     }

      #     Write-Host "Successfully signed msix-output/sparrow.msix"
      #   shell: powershell

      # - name: Add SignTool to PATH
      #   shell: pwsh
      #   run: |
      #     # Find the Windows SDK SignTool
      #     $signTool = Get-ChildItem -Path 'C:\Program Files (x86)\Windows Kits\10\bin' -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
      #                 Where-Object { $_.FullName -match '\\x64\\signtool\.exe$' } |
      #                 Sort-Object LastWriteTime -Descending |
      #                 Select-Object -First 1

      #     if (-not $signTool) {
      #       Write-Host "::error::SignTool.exe not found"
      #       exit 1
      #     }

      #     $signToolDir = $signTool.Directory.FullName
      #     Write-Host "Found SignTool at: $($signTool.FullName)"
      #     Write-Host "Adding to PATH: $signToolDir"
          
      #     # Add to PATH for this step and subsequent steps
      #     $env:PATH = "$signToolDir;$env:PATH"
      #     Add-Content -Path $env:GITHUB_ENV -Value "PATH=$signToolDir;$env:PATH"
          
      #     # Verify it's working
      #     & signtool.exe /?
      #     Write-Host "✅ SignTool added to PATH successfully"

      # - name: Sign MSIX with DigiCert SMCTLSign
      #   run: |
      #     if (-Not (Test-Path msix-output/sparrow.msix)) {
      #         Write-Host "MSIX file not found at msix-output/sparrow.msix"
      #         exit 1
      #     }

      #     Write-Host "Signing: msix-output/sparrow.msix with DigiCert SMCTLSign"
      #     Write-Host "Using keypair alias: $env:KEYPAIR_ALIAS"
      #     Write-Host "SignTool path: $env:SIGNTOOL_PATH"
          
      #     # Set the SIGNTOOL_PATH environment variable for smctl
      #     $env:SIGNTOOL_PATH = "$env:SIGNTOOL_PATH"
          
      #     # Use DigiCert's native signing tool
      #     smctl sign --keypair-alias="$env:KEYPAIR_ALIAS" --input="msix-output/sparrow.msix" --verbose
          
      #     if ($LASTEXITCODE -ne 0) {
      #         Write-Host "Failed to sign msix-output/sparrow.msix with SMCTLSign"
      #         exit 1
      #     }

      #     Write-Host "Successfully signed msix-output/sparrow.msix"
      #   shell: powershell

      - name: Verify MSIX Signature
        run: |
          # Verify the MSIX file exists
          if (-Not (Test-Path msix-output/sparrow.msix)) {
              Write-Host "MSIX file not found at msix-output/sparrow.msix"
              exit 1
          }

          Write-Host "Verifying signature for: msix-output/sparrow.msix"

          # Get the Authenticode signature
          $sig = Get-AuthenticodeSignature -FilePath msix-output/sparrow.msix

          # Check the signature status
          if ($sig.Status -eq 'Valid') {
              Write-Host "Valid signature on msix-output/sparrow.msix"
          } else {
              Write-Host "Invalid signature on msix-output/sparrow.msix: $($sig.Status)"
              exit 1
          }
        shell: powershell

      # --- STAGE 5: DEPLOY ---
      - name: Upload to S3
        run: |
          aws s3 cp msix-output/*.msix s3://sparrow-release-assests-prod/
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Notify Teams
        run: |
          $msix = Get-ChildItem "msix-output/*.msix" | Select-Object -First 1
          $url = "https://sparrow-release-assests-prod.s3.amazonaws.com/$($msix.Name)"
          
          $body = @{
            text = "New MSIX build available: [$($msix.Name)]($url)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ secrets.TEAMS_INCOMING_WEBHOOK_URL }}" -Method Post -Body $body -ContentType 'application/json'
        shell: powershell