# File: .github/workflows/sparrow-app-test-pipeline.yml
# This file is used to test the Sparrow App build and release process. Change this file to trigger the test pipeline for Sparrow App.
# It is triggered on push to the <branch_name> branch. Change the branch name to trigger the test pipeline.

name: Test release

on:
  push:
    # Trigger on push to the <branch_name> branch. Make sure to remove the branch name from the branches list below, once you are done testing.
    branches:
      - fix/msix-build
  workflow_dispatch:

env:
  VITE_API_URL: ${{ vars.VITE_API_URL_DEV }}
  VITE_MIX_PANEL_TOKEN: ${{ vars.VITE_MIX_PANEL_TOKEN }}
  VITE_ENABLE_MIX_PANEL: ${{ vars.VITE_ENABLE_MIX_PANEL_DEV }}
  VITE_API_TIMEOUT: ${{ vars.VITE_API_TIMEOUT }}
  VITE_SPARROW_SUPPORT_EMAIL: ${{ vars.VITE_SPARROW_SUPPORT_EMAIL }}
  VITE_AUTH_URL: ${{ vars.VITE_AUTH_URL_DEV }}
  VITE_SPARROW_GITHUB: ${{ vars.VITE_SPARROW_GITHUB }}
  VITE_SPARROW_DOWNLOAD_LINK: ${{ vars.VITE_SPARROW_DOWNLOAD_LINK }}
  VITE_RELEASE_NOTES_PAT_TOKEN: ${{ secrets.VITE_RELEASE_NOTES_PAT_TOKEN }}
  VITE_RELEASE_NOTES_API: ${{ vars.VITE_RELEASE_NOTES_API }}
  VITE_AZURE_CDN_URL: ${{ vars.VITE_AZURE_CDN_URL }}
  VITE_AZURE_INSIGHTS_CONNECTION_STRING: ${{ vars.VITE_AZURE_INSIGHTS_CONNECTION_STRING }}
  VITE_CANNY_API: ${{ vars.VITE_CANNY_API }}
  VITE_CANNY_URL: ${{ vars.VITE_CANNY_URL }}
  VITE_BASE_URL: ${{ vars.VITE_BASE_URL }}
  VITE_SPARROW_LINKEDIN: ${{ vars.VITE_SPARROW_LINKEDIN }}
  VITE_WEB_SOCKET_IO_API_URL: ${{ vars.VITE_WEB_SOCKET_IO_API_URL }}
  VITE_SPARROW_DOCS: ${{ vars.VITE_SPARROW_DOCS }}
  VITE_SPARROW_AI_WEBSOCKET: ${{ vars.VITE_SPARROW_AI_WEBSOCKET }}
  VITE_APP_ENVIRONMENT_PATH: ${{ vars.VITE_APP_ENVIRONMENT_PATH }}
  VITE_CANNY_FEEDBACK_URL: ${{ vars.VITE_CANNY_FEEDBACK_URL }}
  VITE_SPARROW_WEB_APP_URL: ${{ vars.VITE_SPARROW_WEB_APP_URL }}
  VITE_MARKETING_URL: ${{ vars.VITE_MARKETING_URL }}
  VITE_SENTRY_DSN: ${{ vars.VITE_SENTRY_DSN }}
  VITE_APP_ENVIRONMENT: ${{ vars.VITE_APP_ENVIRONMENT }}
  VITE_POSTHOG_CONNECTION_API_KEY: ${{ vars.VITE_POSTHOG_CONNECTION_API_KEY }}
  VITE_POSTHOG_API_URL: ${{ vars.VITE_POSTHOG_API_URL }}
  VITE_SPARROW_ADMIN_URL: ${{ vars.VITE_SPARROW_ADMIN_URL }}
  ACTIONS_ALLOW_UNSECURE_COMMANDS: true
  CI: false

jobs:
  build_and_sign_msix:
    runs-on: windows-2025
    environment: production

    steps:
      # --- STAGE 1: BUILD TAURI APP (MSI ONLY) ---
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Windows SDK
        uses: microsoft/setup-msbuild@v1

      - name: Copy unsigned MSI from prebuilt
        run: |
          # Create target directory structure
          New-Item -ItemType Directory -Force -Path "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi"
          
          # Copy MSI to where the pipeline expects it
          $msi = Get-ChildItem -Path "prebuilt/Sparrow_*_x64_en-US.msi" | Select-Object -First 1
          if (-not $msi) {
            Write-Host "::error::No MSI found in prebuilt folder"
            exit 1
          }
          
          Copy-Item $msi.FullName -Destination "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/Sparrow.msi"
          Write-Host "Copied $($msi.Name) to standard location"
        shell: powershell

      # --- STAGE 2: SIGN MSI WITH DIGICERT ---
      - name: Set up DigiCert SM Client
        run: |
          echo "${{ secrets.SM_CLIENT_CERT_FILE_B64 }}" | base64 --decode > cert.p12

          # Verify file was created
          if [ ! -f cert.p12 ]; then
            echo "❌ Certificate file not created!"
            exit 1
          fi
          
          # Set environment variables (critical for auth)
          echo "SM_HOST=${{ secrets.SM_HOST }}" >> $GITHUB_ENV
          echo "SM_API_KEY=${{ secrets.SM_API_KEY }}" >> $GITHUB_ENV
          echo "SM_CLIENT_CERT_FILE=$env:GITHUB_WORKSPACE\cert.p12" >> $env:GITHUB_ENV
          echo "SM_CLIENT_CERT_PASSWORD=${{ secrets.SM_CLIENT_CERT_PASSWORD }}" >> $env:GITHUB_ENV
        shell: bash

      - name: Install DigiCert Client tools
        id: digicert-code-signing
        uses: digicert/ssm-code-signing@v1.0.0

      - name: Sign MSI
        run: |
          $msi = Get-ChildItem "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/*.msi" | Select-Object -First 1
          smctl sign --fingerprint ${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }} --input $msi.FullName
        shell: powershell

      # --- STAGE 3: CONVERT TO MSIX ---
      # - name: Inject version into MSIX template
      #   run: |
      #     # Extract only the correct version line under [package]
      #     $cargoFile = "apps/@sparrow-desktop/src-tauri/Cargo.toml"
      #     $versionLine = Select-String -Path $cargoFile -Pattern '^\s*version\s*=\s*"(.*?)"' | Select-Object -First 1
      #     $version = $versionLine.Matches.Groups[1].Value + ".0"

      #     # Update MSIX template
      #     $templatePath = ".github/workflows/msix_packaging/sparrow_template.xml"

      #     (Get-Content $templatePath -Raw) -replace "{{PACKAGE_VERSION}}", $version | 
      #       Set-Content $templatePath -Encoding UTF8

      #     (Get-Content $templatePath -Raw) -replace "{{MSIX_PACKAGE_PATH}}", "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/Sparrow.msi" | 
      #       Set-Content $templatePath -Encoding UTF8

      #     # Print version
      #     Write-Host "`n✅ MSIX version set to: $version"

      #     # Print Msix Package Path
      #     Write-Host "`n✅ MSIX package path set to: apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/Sparrow.msi"

      #   shell: powershell

      # --- STAGE 3: CONVERT TO MSIX USING MAKEAPPX ---
      - name: Prepare App Folder for MakeAppx
        run: |
          $msiPath = "apps/@sparrow-desktop/src-tauri/target/debug/bundle/msi/Sparrow.msi"
          $destinationPath = "app-root"

          # Create destination directory if it doesn't exist
          New-Item -ItemType Directory -Force -Path $destinationPath

          # Extract MSI contents
          Start-Process -Wait -FilePath "msiexec.exe" -ArgumentList "/a `"$msiPath`" /qn TARGETDIR=`"$(Resolve-Path $destinationPath)`""
        shell: powershell

      - name: Generate AppxManifest.xml with version injection
        run: |
          $cargoFile = "apps/@sparrow-desktop/src-tauri/Cargo.toml"
          $versionLine = Select-String -Path $cargoFile -Pattern '^[\s]*version\s*=\s*\"(.*?)\"' | Select-Object -First 1
          $version = $versionLine.Matches.Groups[1].Value

          $manifest = @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
                  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
                  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10">
            <Identity Name="Sparrow"
                      Publisher="CN=Techdome Solutions, O=Techdome Solutions, C=IN"
                      Version="$version.0"
                      ProcessorArchitecture="x64" />
            <Properties>
              <DisplayName>Sparrow</DisplayName>
              <PublisherDisplayName>sparrowapp</PublisherDisplayName>
              <Description>Sparrow</Description>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.0.0" MaxVersionTested="10.0.19041.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-us" />
            </Resources>
            <Applications>
              <Application Id="SparrowApp" Executable="Sparrow.exe" EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements DisplayName="Sparrow" Description="Sparrow App" BackgroundColor="transparent" Square150x150Logo="Assets\Square150x150Logo.png" Square44x44Logo="Assets\Square44x44Logo.png">
                  <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" />
                  <uap:SplashScreen Image="Assets\SplashScreen.png" />
                </uap:VisualElements>
              </Application>
            </Applications>
          </Package>
          "@

          $manifest | Set-Content -Encoding UTF8 -Path "app-root\AppxManifest.xml"
        shell: powershell

      - name: Create MSIX Package using MakeAppx
        run: |
          New-Item -ItemType Directory -Force -Path "msix-output"
          $msixPath = "msix-output/sparrow.msix"

          $makeappxPath = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "MakeAppx.exe" |
                          Where-Object { $_.FullName -like "*\\x64\\MakeAppx.exe" } |
                          Sort-Object FullName -Descending |
                          Select-Object -First 1

          if (-not $makeappxPath) {
            Write-Host "::error::MakeAppx.exe not found on system"
            exit 1
          }

          & "$($makeappxPath.FullName)" pack /d "app-root" /p $msixPath
        shell: powershell

      # --- STAGE 4: SIGN MSIX WITH DIGICERT ---
      - name: Sign MSIX
        run: |
          $msix = Get-ChildItem "msix-output/*.msix" | Select-Object -First 1
          smctl sign --fingerprint ${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }} --input $msix.FullName
        shell: powershell

      - name: Verify Signature
        run: |
          $msix = Get-ChildItem "msix-output/*.msix" | Select-Object -First 1
          $result = smctl verify --input $msix.FullName
          if (-not $result.Contains("Valid: True")) { 
            throw "MSIX signature verification failed" 
          }
        shell: powershell

      # --- STAGE 5: DEPLOY ---
      - name: Upload to S3
        run: |
          aws s3 cp msix-output/*.msix s3://sparrow-release-assests-prod/
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Notify Teams
        run: |
          $msix = Get-ChildItem "msix-output/*.msix" | Select-Object -First 1
          $url = "https://sparrow-release-assests-prod.s3.amazonaws.com/$($msix.Name)"
          
          $body = @{
            text = "New MSIX build available: [$($msix.Name)]($url)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ secrets.TEAMS_INCOMING_WEBHOOK_URL }}" -Method Post -Body $body -ContentType 'application/json'
        shell: powershell